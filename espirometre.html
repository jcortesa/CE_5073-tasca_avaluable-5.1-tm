<!DOCTYPE html>
<html lang="ca">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Espiròmetre visual amb Teachable Machine</title>
    <style>
        :root {
            color-scheme: light;
        }

        body {
            margin: 0;
            font-family: Arial, sans-serif;
            background: #f3f4f6;
            color: #111827;
            display: grid;
            place-items: center;
            min-height: 100vh;
        }

        .app {
            width: min(980px, 96vw);
            background: #ffffff;
            border-radius: 14px;
            padding: 18px;
            box-shadow: 0 10px 35px rgba(0, 0, 0, 0.12);
        }

        h1 {
            margin: 0 0 8px;
            font-size: 1.5rem;
        }

        p {
            margin: 0;
            color: #374151;
        }

        .controls {
            margin: 14px 0 10px;
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 10px;
        }

        button {
            border: 0;
            border-radius: 10px;
            padding: 10px 14px;
            font-weight: 600;
            cursor: pointer;
        }

        #startBtn {
            background: #2563eb;
            color: #ffffff;
        }

        #stopBtn {
            background: #e5e7eb;
            color: #111827;
        }

        #status {
            font-weight: 600;
        }

        #canvasWrap {
            width: 100%;
            overflow: hidden;
            border-radius: 12px;
            background: linear-gradient(180deg, #f8fbff 0%, #e8f0f8 100%);
            border: 1px solid #d1d5db;
        }

        #spirometerCanvas {
            display: block;
            width: 100%;
            height: auto;
        }

        .metrics {
            margin-top: 10px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 8px;
            font-size: 0.95rem;
            color: #1f2937;
        }

        .metric {
            background: #f9fafb;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            padding: 8px 10px;
        }

        .labels {
            margin-top: 10px;
            max-height: 170px;
            overflow: auto;
            background: #f9fafb;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            padding: 8px;
            font-size: 0.9rem;
        }

        .labels div {
            padding: 2px 0;
        }
    </style>
</head>
<body>
    <main class="app">
        <h1>Espiròmetre visual (Canvas + Teachable Machine)</h1>
        <p>Bufa cap al micròfon: les bolles pujaran segons la força de bufec detectada pel model.</p>

        <div class="controls">
            <button id="startBtn" type="button">Inicia</button>
            <button id="stopBtn" type="button" disabled>Atura</button>
            <span id="status">Model no iniciat</span>
        </div>

        <div id="canvasWrap">
            <canvas id="spirometerCanvas" width="960" height="540"></canvas>
        </div>

        <div class="metrics">
            <div class="metric">Força instantània: <strong id="instantForce">0%</strong></div>
            <div class="metric">Força suavitza: <strong id="smoothForce">0%</strong></div>
            <div class="metric">Classe dominant: <strong id="topClass">-</strong></div>
        </div>

        <div id="label-container" class="labels"></div>
    </main>

    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@1.3.1/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/speech-commands@0.4.0/dist/speech-commands.min.js"></script>

    <script>
        const MODEL_URL = "https://teachablemachine.withgoogle.com/models/sW6fvhLo4/";

        const canvas = document.getElementById("spirometerCanvas");
        const ctx = canvas.getContext("2d");
        const statusEl = document.getElementById("status");
        const startBtn = document.getElementById("startBtn");
        const stopBtn = document.getElementById("stopBtn");
        const labelContainer = document.getElementById("label-container");
        const instantForceEl = document.getElementById("instantForce");
        const smoothForceEl = document.getElementById("smoothForce");
        const topClassEl = document.getElementById("topClass");

        let recognizer = null;
        let classLabels = [];
        let isListening = false;

        let instantaneousForce = 0;
        let smoothedForce = 0;
        let topClass = "-";

        const ballStates = [
            { color: "#ef4444", radius: 22, heightNorm: 0 },
            { color: "#f59e0b", radius: 22, heightNorm: 0 },
            { color: "#22c55e", radius: 22, heightNorm: 0 }
        ];

        const tubeThresholds = [0.2, 0.5, 0.8];
        const riseSpeed = 0.08;
        const fallSpeed = 0.02;

        function setStatus(text, isError = false) {
            statusEl.textContent = text;
            statusEl.style.color = isError ? "#b91c1c" : "#111827";
        }

        function updateMetricText() {
            instantForceEl.textContent = `${Math.round(instantaneousForce * 100)}%`;
            smoothForceEl.textContent = `${Math.round(smoothedForce * 100)}%`;
            topClassEl.textContent = topClass;
        }

        function isNoiseLike(label) {
            const lower = label.toLowerCase();
            return lower.includes("noise") || lower.includes("unknown") || lower.includes("silence") || lower.includes("soroll") || lower.includes("desconegut");
        }

        function computeBlowForce(scores) {
            let weightedSum = 0;
            let weightTotal = 0;

            for (let i = 0; i < scores.length; i++) {
                const label = classLabels[i] || "";
                const score = scores[i];
                const weight = isNoiseLike(label) ? 0.15 : 1;
                weightedSum += score * weight;
                weightTotal += weight;
            }

            if (weightTotal === 0) {
                return 0;
            }

            const meanScore = weightedSum / weightTotal;
            const maxScore = Math.max(...scores);
            const combined = (meanScore * 0.35) + (maxScore * 0.65);
            return Math.max(0, Math.min(1, combined));
        }

        async function createModel() {
            const checkpointURL = MODEL_URL + "model.json";
            const metadataURL = MODEL_URL + "metadata.json";

            const createdRecognizer = speechCommands.create(
                "BROWSER_FFT",
                undefined,
                checkpointURL,
                metadataURL
            );

            await createdRecognizer.ensureModelLoaded();
            return createdRecognizer;
        }

        async function startListening() {
            if (isListening) {
                return;
            }

            try {
                setStatus("Carregant model...");

                if (!recognizer) {
                    recognizer = await createModel();
                    classLabels = recognizer.wordLabels();
                    labelContainer.innerHTML = "";
                    classLabels.forEach(() => {
                        labelContainer.appendChild(document.createElement("div"));
                    });
                }

                setStatus("Escoltant micròfon...");

                recognizer.listen(result => {
                    const scores = result.scores;
                    instantaneousForce = computeBlowForce(scores);
                    smoothedForce += (instantaneousForce - smoothedForce) * 0.2;

                    let maxIndex = 0;
                    for (let i = 1; i < scores.length; i++) {
                        if (scores[i] > scores[maxIndex]) {
                            maxIndex = i;
                        }
                    }

                    topClass = classLabels[maxIndex] || "-";

                    for (let i = 0; i < classLabels.length; i++) {
                        labelContainer.childNodes[i].textContent = `${classLabels[i]}: ${scores[i].toFixed(2)}`;
                    }

                    updateMetricText();
                }, {
                    includeSpectrogram: false,
                    probabilityThreshold: 0.55,
                    invokeCallbackOnNoiseAndUnknown: true,
                    overlapFactor: 0.5
                });

                isListening = true;
                startBtn.disabled = true;
                stopBtn.disabled = false;
            } catch (error) {
                setStatus(`Error: ${error.message}`, true);
                isListening = false;
                startBtn.disabled = false;
                stopBtn.disabled = true;
            }
        }

        function stopListening() {
            if (recognizer && isListening) {
                recognizer.stopListening();
            }

            isListening = false;
            instantaneousForce = 0;
            topClass = "-";
            setStatus("Aturat");
            startBtn.disabled = false;
            stopBtn.disabled = true;
            updateMetricText();
        }

        function drawRoundedRect(x, y, w, h, radius) {
            const r = Math.min(radius, w / 2, h / 2);
            ctx.beginPath();
            ctx.moveTo(x + r, y);
            ctx.arcTo(x + w, y, x + w, y + h, r);
            ctx.arcTo(x + w, y + h, x, y + h, r);
            ctx.arcTo(x, y + h, x, y, r);
            ctx.arcTo(x, y, x + w, y, r);
            ctx.closePath();
        }

        function drawHose(baseX, baseY, width) {
            const startX = baseX - width * 0.15;
            const endX = baseX + width * 0.95;
            const amp = 28;
            const steps = 50;

            ctx.save();
            ctx.lineWidth = 24;
            ctx.strokeStyle = "#1d4ed8";
            ctx.lineCap = "round";
            ctx.beginPath();
            for (let i = 0; i <= steps; i++) {
                const t = i / steps;
                const x = startX + (endX - startX) * t;
                const y = baseY + Math.sin(t * Math.PI * 2.8) * amp + 74;
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.stroke();

            ctx.lineWidth = 2;
            ctx.strokeStyle = "rgba(255,255,255,0.35)";
            for (let i = 0; i <= 34; i++) {
                const t = i / 34;
                const x = startX + (endX - startX) * t;
                const y = baseY + Math.sin(t * Math.PI * 2.8) * amp + 74;
                const nx = endX - startX;
                const ny = 0;
                const len = Math.hypot(nx, ny) || 1;
                const px = -ny / len;
                const py = nx / len;
                ctx.beginPath();
                ctx.moveTo(x - px * 10, y - py * 10);
                ctx.lineTo(x + px * 10, y + py * 10);
                ctx.stroke();
            }

            ctx.fillStyle = "#bfdbfe";
            drawRoundedRect(endX + 6, baseY + 118, 54, 24, 6);
            ctx.fill();
            ctx.restore();
        }

        function drawSpirometer() {
            const w = canvas.width;
            const h = canvas.height;

            ctx.clearRect(0, 0, w, h);

            const frameX = w * 0.2;
            const frameY = h * 0.08;
            const frameW = w * 0.42;
            const frameH = h * 0.72;

            const baseY = frameY + frameH;
            const tubeTop = frameY + 20;
            const tubeBottom = baseY - 16;
            const tubeHeight = tubeBottom - tubeTop;

            const tubeGap = frameW * 0.03;
            const tubeW = (frameW - tubeGap * 4) / 3;

            drawHose(frameX, baseY, frameW);

            ctx.fillStyle = "rgba(200, 220, 255, 0.25)";
            ctx.strokeStyle = "rgba(150, 175, 200, 0.75)";
            ctx.lineWidth = 2;
            drawRoundedRect(frameX, frameY, frameW, frameH, 16);
            ctx.fill();
            ctx.stroke();

            for (let i = 0; i < 3; i++) {
                const tubeX = frameX + tubeGap + i * (tubeW + tubeGap);

                ctx.fillStyle = "rgba(255, 255, 255, 0.35)";
                ctx.strokeStyle = "rgba(160, 180, 205, 0.9)";
                ctx.lineWidth = 2;
                drawRoundedRect(tubeX, tubeTop, tubeW, tubeHeight, 12);
                ctx.fill();
                ctx.stroke();

                for (let m = 1; m < 6; m++) {
                    const markY = tubeBottom - (tubeHeight / 6) * m;
                    ctx.strokeStyle = "rgba(140, 160, 180, 0.4)";
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(tubeX + 8, markY);
                    ctx.lineTo(tubeX + tubeW - 8, markY);
                    ctx.stroke();
                }

                const target = Math.max(0, Math.min(1, (smoothedForce - tubeThresholds[i]) / (1 - tubeThresholds[i])));
                const speed = target > ballStates[i].heightNorm ? riseSpeed : fallSpeed;
                ballStates[i].heightNorm += (target - ballStates[i].heightNorm) * speed;

                const lift = ballStates[i].heightNorm * (tubeHeight - 62);
                const ballY = tubeBottom - 22 - lift;
                const ballX = tubeX + tubeW / 2;

                ctx.beginPath();
                ctx.fillStyle = ballStates[i].color;
                ctx.arc(ballX, ballY, ballStates[i].radius, 0, Math.PI * 2);
                ctx.fill();

                const grad = ctx.createRadialGradient(ballX - 8, ballY - 8, 2, ballX, ballY, ballStates[i].radius);
                grad.addColorStop(0, "rgba(255,255,255,0.8)");
                grad.addColorStop(1, "rgba(255,255,255,0)");
                ctx.beginPath();
                ctx.fillStyle = grad;
                ctx.arc(ballX, ballY, ballStates[i].radius, 0, Math.PI * 2);
                ctx.fill();
            }

            ctx.fillStyle = "#4b5563";
            ctx.font = "600 16px Arial";
            ctx.fillText("Força de bufec", frameX + frameW + 36, frameY + 34);

            const meterX = frameX + frameW + 52;
            const meterY = frameY + 58;
            const meterW = 26;
            const meterH = frameH - 100;

            ctx.fillStyle = "#e5e7eb";
            drawRoundedRect(meterX, meterY, meterW, meterH, 10);
            ctx.fill();

            const levelH = meterH * smoothedForce;
            const levelY = meterY + meterH - levelH;
            const meterGrad = ctx.createLinearGradient(0, meterY + meterH, 0, meterY);
            meterGrad.addColorStop(0, "#60a5fa");
            meterGrad.addColorStop(1, "#16a34a");
            ctx.fillStyle = meterGrad;
            drawRoundedRect(meterX, levelY, meterW, levelH, 10);
            ctx.fill();

            ctx.strokeStyle = "#9ca3af";
            ctx.strokeRect(meterX, meterY, meterW, meterH);

            ctx.fillStyle = "#111827";
            ctx.font = "700 18px Arial";
            ctx.fillText(`${Math.round(smoothedForce * 100)}%`, meterX - 6, meterY + meterH + 28);
        }

        function animationLoop() {
            smoothedForce *= isListening ? 0.995 : 0.96;
            updateMetricText();
            drawSpirometer();
            requestAnimationFrame(animationLoop);
        }

        startBtn.addEventListener("click", startListening);
        stopBtn.addEventListener("click", stopListening);

        updateMetricText();
        animationLoop();
    </script>
</body>
</html>